import{r as l,V as y,R as E}from"./iframe-BDiSHtTr.js";import{j as P}from"./jsx-runtime-D_zvdyIk.js";import{u as w,c as b}from"./index-BuyJf9xW.js";function H(e,n,{checkForDefaultPrevented:t=!0}={}){return function(c){if(e?.(c),t===!1||!c.defaultPrevented)return n?.(c)}}function N(e,n=[]){let t=[];function a(r,s){const o=l.createContext(s),d=t.length;t=[...t,s];const m=i=>{const{scope:I,children:v,...R}=i,p=I?.[e]?.[d]||o,f=l.useMemo(()=>R,Object.values(R));return P.jsx(p.Provider,{value:f,children:v})};m.displayName=r+"Provider";function u(i,I){const v=I?.[e]?.[d]||o,R=l.useContext(v);if(R)return R;if(s!==void 0)return s;throw new Error(`\`${i}\` must be used within \`${r}\``)}return[m,u]}const c=()=>{const r=t.map(s=>l.createContext(s));return function(o){const d=o?.[e]||r;return l.useMemo(()=>({[`__scope${e}`]:{...o,[e]:d}}),[o,d])}};return c.scopeName=e,[a,A(c,...n)]}function A(...e){const n=e[0];if(e.length===1)return n;const t=()=>{const a=e.map(c=>({useScope:c(),scopeName:c.scopeName}));return function(r){const s=a.reduce((o,{useScope:d,scopeName:m})=>{const i=d(r)[`__scope${m}`];return{...o,...i}},{});return l.useMemo(()=>({[`__scope${n.scopeName}`]:s}),[s])}};return t.scopeName=n.scopeName,t}var T=globalThis?.document?l.useLayoutEffect:()=>{},$=y[" useInsertionEffect ".trim().toString()]||T;function U({prop:e,defaultProp:n,onChange:t=()=>{},caller:a}){const[c,r,s]=O({defaultProp:n,onChange:t}),o=e!==void 0,d=o?e:c;{const u=l.useRef(e!==void 0);l.useEffect(()=>{const i=u.current;i!==o&&console.warn(`${a} is changing from ${i?"controlled":"uncontrolled"} to ${o?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=o},[o,a])}const m=l.useCallback(u=>{if(o){const i=j(u)?u(e):u;i!==e&&s.current?.(i)}else r(u)},[o,e,r,s]);return[d,m]}function O({defaultProp:e,onChange:n}){const[t,a]=l.useState(e),c=l.useRef(t),r=l.useRef(n);return $(()=>{r.current=n},[n]),l.useEffect(()=>{c.current!==t&&(r.current?.(t),c.current=t)},[t,c]),[t,a,r]}function j(e){return typeof e=="function"}function q(e){const n=e+"CollectionProvider",[t,a]=N(n),[c,r]=t(n,{collectionRef:{current:null},itemMap:new Map}),s=p=>{const{scope:f,children:M}=p,C=E.useRef(null),x=E.useRef(new Map).current;return P.jsx(c,{scope:f,itemMap:x,collectionRef:C,children:M})};s.displayName=n;const o=e+"CollectionSlot",d=b(o),m=E.forwardRef((p,f)=>{const{scope:M,children:C}=p,x=r(o,M),S=w(f,x.collectionRef);return P.jsx(d,{ref:S,children:C})});m.displayName=o;const u=e+"CollectionItemSlot",i="data-radix-collection-item",I=b(u),v=E.forwardRef((p,f)=>{const{scope:M,children:C,...x}=p,S=E.useRef(null),_=w(f,S),h=r(u,M);return E.useEffect(()=>(h.itemMap.set(S,{ref:S,...x}),()=>void h.itemMap.delete(S))),P.jsx(I,{[i]:"",ref:_,children:C})});v.displayName=u;function R(p){const f=r(e+"CollectionConsumer",p);return E.useCallback(()=>{const C=f.collectionRef.current;if(!C)return[];const x=Array.from(C.querySelectorAll(`[${i}]`));return Array.from(f.itemMap.values()).sort((h,g)=>x.indexOf(h.ref.current)-x.indexOf(g.ref.current))},[f.collectionRef,f.itemMap])}return[{Provider:s,Slot:m,ItemSlot:v},R,a]}var D=l.createContext(void 0);function B(e){const n=l.useContext(D);return e||n||"ltr"}export{H as a,T as b,N as c,q as d,B as e,U as u};
